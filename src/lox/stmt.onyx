#load "./token"

use core { Result }
use core.list

Stmt :: union {
    Expression: ExpressionStmt;
    Print: PrintStmt;
    Var: VarStmt;
    Block: BlockStmt;
    If: IfStmt;

    accept :: (stmt: Stmt, visitor: $T) -> Result(void, RuntimeError) where StmtVisitor(T) {
        switch stmt {
            case s: .If {
                return visitor->visit_if_stmt(s);
            }
            case s: .Expression {
                return visitor->visit_expression_stmt(s);
            }
            case s: .Print {
                return visitor->visit_print_stmt(s);
            }
            case s: .Var {
                return visitor->visit_var_stmt(s);
            }
            case s: .Block {
                return visitor->visit_block_stmt(s);
            }
        }
    }
}

ExpressionStmt :: struct {
    expression: Expr;
}

IfStmt :: struct {
    condition: Expr;
    then_branch: &Stmt;
    else_branch: &Stmt;
}

PrintStmt :: struct {
    expression: Expr;
}

VarStmt :: struct {
    name: Token;
    initializer: ?Expr;
}

BlockStmt :: struct {
    // NOTE: this cannot have list.List(Stmt) due to circular definement
    statements: list.List(&Stmt);
}

StmtVisitor :: interface (t: $T) {
    { t->visit_if_stmt(IfStmt.{}) } -> Result(void, RuntimeError);
    { t->visit_expression_stmt(ExpressionStmt.{}) } -> Result(void, RuntimeError);
    { t->visit_print_stmt(PrintStmt.{}) } -> Result(void, RuntimeError);
    { t->visit_var_stmt(VarStmt.{}) } -> Result(void, RuntimeError);
    { t->visit_block_stmt(BlockStmt.{}) } -> Result(void, RuntimeError);
}
