#load "./token"

use core { printf }
use core.slice

Expr :: union {
    Binary: BinaryExpr;
    Literal: LiteralExpr;
    Group: GroupExpr;

    accept :: (expr: Expr, visitor: $T) -> LoxObject where Visitor(T) {
        switch expr {
            case e: .Binary {
                return visitor->visitBinaryExpr(e);
            }
            case e: .Literal {
                return visitor->visitLiteralExpr(e);
            }
            case e: .Group {
                return visitor->visitGroupExpr(e);
            }
        }
    }
}

// NOTE: Expr should be a pointer, otherwise the struct initialization fails due to circular reference
BinaryExpr :: struct {
    left: &Expr;
    operator: Token;
    right: &Expr;
}

LiteralExpr :: struct {
    value: TokenLiteral;
}

GroupExpr :: struct {
    expression: &Expr;
}

Visitor :: interface (t: $T) {
    { t->visitBinaryExpr(BinaryExpr.{}) } -> LoxObject;
    { t->visitLiteralExpr(LiteralExpr.{}) } -> LoxObject;
    { t->visitGroupExpr(GroupExpr.{}) } -> LoxObject;
}
