#load "./runtime_error"
#load "./token"

use core { printf, Result }
use core.slice

Expr :: union {
    Literal: LiteralExpr;
    Binary: BinaryExpr;
    Unary: UnaryExpr;
    Group: GroupExpr;
    Variable: VariableExpr;

    accept :: (expr: Expr, visitor: $T) -> Result(LoxObject, RuntimeError) where Visitor(T) {
        switch expr {
            case e: .Literal {
                return visitor->visit_literal_expr(e);
            }
            case e: .Binary {
                return visitor->visit_binary_expr(e);
            }
            case e: .Unary {
                return visitor->visit_unary_expr(e);
            }
            case e: .Group {
                return visitor->visit_group_expr(e);
            }
            case e: .Variable {
                return visitor->visit_variable_expr(e);
            }
        }
    }
}

// NOTE: Expr should be a pointer, otherwise the struct initialization fails due to circular reference
BinaryExpr :: struct {
    left: &Expr;
    operator: Token;
    right: &Expr;
}

UnaryExpr :: struct {
    operator: Token;
    right: &Expr;
}

LiteralExpr :: struct {
    value: TokenLiteral;
}

GroupExpr :: struct {
    expression: &Expr;
}

VariableExpr :: struct {
    name: Token;
}

Visitor :: interface (t: $T) {
    { t->visit_literal_expr(LiteralExpr.{}) } -> Result(LoxObject, RuntimeError);
    { t->visit_binary_expr(BinaryExpr.{}) } -> Result(LoxObject, RuntimeError);
    { t->visit_unary_expr(UnaryExpr.{}) } -> Result(LoxObject, RuntimeError);
    { t->visit_group_expr(GroupExpr.{}) } -> Result(LoxObject, RuntimeError);
    { t->visit_variable_expr(VariableExpr.{}) } -> Result(LoxObject, RuntimeError);
}
