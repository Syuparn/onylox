#load "./expr"
#load "./object"
#load "./runtime_error"

use core
use core { printf, Result, tprintf }

Interpreter :: struct {
    // HACK: receiver must have non-void fields, otherwise the error `Function parameters cannot have 'void' as their type.` is raised
    _dummy: bool;

    evaluate :: (interpreter: Interpreter, expr: Expr) -> Result(LoxObject, RuntimeError) {
        return expr->accept(interpreter);
    }

    visit_literal_expr :: (interpreter: Interpreter, expr: LiteralExpr) -> Result(LoxObject, RuntimeError) {
        switch expr.value {
            case s: .String {
                return .{Ok=LoxObject.{String=s}};
            }
            case b: .Bool {
                return .{Ok=LoxObject.{Bool=b}};
            }
            case n: .Number {
                return .{Ok=LoxObject.{Number=n}};
            }
            case .Null {
                return .{Ok=LoxObject.{Null=.{}}};
            }
        }
    }

    visit_group_expr :: (interpreter: Interpreter, expr: GroupExpr) -> Result(LoxObject, RuntimeError) {
        return interpreter->evaluate(*expr.expression);
    }

    visit_binary_expr :: (interpreter: Interpreter, expr: BinaryExpr) -> Result(LoxObject, RuntimeError) {
        // NOTE: left must be evaluated first for side-effect order
        left := interpreter->evaluate(*expr.left)->forward_err();
        right := interpreter->evaluate(*expr.right)->forward_err();

        switch expr.operator.type {
            case TokenType.MINUS {
                return .{Ok=LoxObject.{Number=left.Number? - right.Number?}};
            }
            case TokenType.SLASH {
                return .{Ok=LoxObject.{Number=left.Number? / right.Number?}};
            }
            case TokenType.STAR {
                return .{Ok=LoxObject.{Number=left.Number? * right.Number?}};
            }
            case TokenType.PLUS {
                switch left {
                    case ln: .Number {
                        return .{Ok=LoxObject.{Number=ln + right.Number?}};
                    }
                    case ls: .String {
                        return .{Ok=LoxObject.{String=tprintf("{}{}", ls, right.String?)}};
                    }
                    case #default ---
                }
            }
            case TokenType.GREATER {
                return .{Ok=LoxObject.{Bool=left.Number? > right.Number?}};
            }
            case TokenType.GREATER_EQUAL {
                return .{Ok=LoxObject.{Bool=left.Number? >= right.Number?}};
            }
            case TokenType.LESS {
                return .{Ok=LoxObject.{Bool=left.Number? < right.Number?}};
            }
            case TokenType.LESS_EQUAL {
                return .{Ok=LoxObject.{Bool=left.Number? <= right.Number?}};
            }
            case TokenType.EQUAL_EQUAL {
                return .{Ok=LoxObject.{Bool=interpreter->_is_equal(left, right)}};
            }
            case TokenType.BANG_EQUAL {
                return .{Ok=LoxObject.{Bool=!interpreter->_is_equal(left, right)}};
            }
        }

        // TODO: impl
        return .{Ok=LoxObject.{Null=.{}}};
    }

    visit_unary_expr :: (interpreter: Interpreter, expr: UnaryExpr) -> Result(LoxObject, RuntimeError) {
        right := interpreter->evaluate(*expr.right)->forward_err();

        switch expr.operator.type {
            case TokenType.MINUS {
                interpreter->_check_number_operand(expr.operator, right)->forward_err();
                return .{Ok=LoxObject.{Number=-right.Number?}};
            }
            case TokenType.BANG {
                // TODO: error handling
                return .{Ok=LoxObject.{Bool=!interpreter->_is_truthy(right)}};
            }
        }

        // unreachable
        return .{Ok=right};
    }

    _is_truthy :: (interpreter: Interpreter, obj: LoxObject) -> bool {
        switch obj {
            case .Null {
                return false;
            }
            case b: .Bool {
                return b;
            }
            case #default {
                return true;
            }
        }
    }

    _is_equal :: (interpreter: Interpreter, left: LoxObject, right: LoxObject) -> bool {
        return left == right;
    }

    // HACK: returned LoxObject is not used (it is only defined for forward_err() method)
    _check_number_operand :: (interpreter: Interpreter, token: Token, operand: LoxObject) -> Result(LoxObject, RuntimeError) {
        switch operand {
            case .Number {
                return .{Ok=.{}};
            }
            case #default {
                return .{Err=RuntimeError.{token=token, message="Operand must be a number."}};
            }
        }
    }
}
