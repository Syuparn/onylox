#load "./environment.onyx"
#load "./interpreter.onyx"
#load "./stmt.onyx"

use core {Result}
use core.list

LoxFunction :: struct {
    declaration: FunctionStmt;
    closure: &Environment;

    call :: (f: LoxFunction, interpreter: &Interpreter, arguments: list.List(LoxObject)) -> Result(LoxObject, RuntimeError) {
        // NOTE: define arguments as l-value
        args := arguments;

        // create function scope
        // TODO: free pointer
        environment := Environment.{enclosing=f.closure};

        for i: 0..f.declaration.params->count() {
            environment->define(f.declaration.params->at(i).lexeme, *(&args)->at(i));
        }

        result := interpreter->execute_block(f.declaration.body, environment);
        if result->is_err() {
            err := result->err()?;

            // HACK: if value exists, it is a returned value from function
            if !is_empty(err.value) {
                return .{Ok=err.value?};
            }

            return .{Err=err};
        }

        return .{Ok=LoxObject.{Null=.{}}};
    }

    arity :: (f: LoxFunction) -> u8 {
        return cast(u8) f.declaration.params->count();
    }
}
