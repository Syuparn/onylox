#load "./hash"
#load "./runtime_error"
#load "./token"

use core { printf, Result }
use core.list
use core.slice

Expr :: union {
    Literal: LiteralExpr;
    Logical: LogicalExpr;
    Binary: BinaryExpr;
    Unary: UnaryExpr;
    Group: GroupExpr;
    Variable: VariableExpr;
    Assign: AssignExpr;
    Call: CallExpr;

    accept :: (expr: Expr, visitor: $T) -> Result(LoxObject, RuntimeError) where Visitor(T) {
        switch expr {
            case e: .Literal {
                return visitor->visit_literal_expr(e);
            }
            case e: .Logical {
                return visitor->visit_logical_expr(e);
            }
            case e: .Binary {
                return visitor->visit_binary_expr(e);
            }
            case e: .Unary {
                return visitor->visit_unary_expr(e);
            }
            case e: .Group {
                return visitor->visit_group_expr(e);
            }
            case e: .Variable {
                return visitor->visit_variable_expr(e);
            }
            case e: .Assign {
                return visitor->visit_assign_expr(e);
            }
            case e: .Call {
                return visitor->visit_call_expr(e);
            }
        }
    }

    hash :: (expr: Expr) -> u32 {
        switch expr {
            case e: .Literal {
                return e._hash;
            }
            case e: .Logical {
                return e._hash;
            }
            case e: .Binary {
                return e._hash;
            }
            case e: .Unary {
                return e._hash;
            }
            case e: .Group {
                return e._hash;
            }
            case e: .Variable {
                return e._hash;
            }
            case e: .Assign {
                return e._hash;
            }
            case e: .Call {
                return e._hash;
            }
        }
    }
}

#operator == (expr1: Expr, expr2: Expr) -> bool {
    // NOTE: exprs should be compared by identity (not equivalence), otherwise equivalent expr in different place are mistaken by resolver
    return expr1->hash() == expr2->hash();
}

// NOTE: Expr should be a pointer, otherwise the struct initialization fails due to circular reference
BinaryExpr :: struct {
    left: &Expr;
    operator: Token;
    right: &Expr;
    _hash: u32 = new_hash();
}

UnaryExpr :: struct {
    operator: Token;
    right: &Expr;
    _hash: u32 = new_hash();
}

LiteralExpr :: struct {
    value: TokenLiteral;
    _hash: u32 = new_hash();
}

GroupExpr :: struct {
    expression: &Expr;
    _hash: u32 = new_hash();
}

VariableExpr :: struct {
    name: Token;
    _hash: u32 = new_hash();
}

AssignExpr :: struct {
    name: Token;
    value: &Expr;
    _hash: u32 = new_hash();
}

LogicalExpr :: struct {
    left: &Expr;
    operator: Token;
    right: &Expr;
    _hash: u32 = new_hash();
}

CallExpr :: struct {
    callee: &Expr;
    paren: Token;
    arguments: list.List(&Expr);
    _hash: u32 = new_hash();
}

Visitor :: interface (t: $T) {
    { t->visit_literal_expr(LiteralExpr.{}) } -> Result(LoxObject, RuntimeError);
    { t->visit_logical_expr(LogicalExpr.{}) } -> Result(LoxObject, RuntimeError);
    { t->visit_binary_expr(BinaryExpr.{}) } -> Result(LoxObject, RuntimeError);
    { t->visit_unary_expr(UnaryExpr.{}) } -> Result(LoxObject, RuntimeError);
    { t->visit_group_expr(GroupExpr.{}) } -> Result(LoxObject, RuntimeError);
    { t->visit_variable_expr(VariableExpr.{}) } -> Result(LoxObject, RuntimeError);
    { t->visit_assign_expr(AssignExpr.{}) } -> Result(LoxObject, RuntimeError);
    { t->visit_call_expr(CallExpr.{}) } -> Result(LoxObject, RuntimeError);
}
